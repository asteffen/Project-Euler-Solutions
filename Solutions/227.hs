import Data.Function (on)
import Data.List (sortBy, groupBy)
import Data.Ratio ((%))
import Matrix

-- generates an equation of the form [(separation, coefficient)].
genEq :: Integer -> [(Integer, Integer)]
genEq k = [(k - 2, 1), (k - 1, 8), (k, -18), (k + 1, 8), (k + 2, 1)]

-- given: (n)  = the size of the table
--        (eq) = list of equations returned by (genEq).
-- returns: (eq), simplified according to 3 rules.
-- notation: g(k) = the expected number of turns the game lasts with the dice
--                  starting with a separation of (k).
-- note: uses concatMap and singleton lists so that when g(0) occurs, it can
--       be removed from the list.
simplify :: Integer -> [(Integer, Integer)] -> [(Integer, Integer)]
simplify n eq = concatMap simplify' eq
	where
		-- Rule 1:  g(-1) == g(1).
		simplify' (-1,  coef) = [(1, coef)]
		-- Rule 2: g(0) == 0.
		simplify' (0,   coef) = []
		-- Rule 3: g(k) == g(n - k).
		simplify' pair@(sep, coef)
			| sep > n `div` 2 = [(n - sep, coef)]
			| otherwise = [pair]

-- combines like terms in a simplified equation.
combine :: [(Integer, Integer)] -> [(Integer, Integer)]
combine = map (f . unzip) . groupBy ((==) `on` fst) . sortBy (compare `on` fst)
	where f (seps, coefs) = (head seps, sum coefs)

-- converts an equation of the form [(separation, coefficient)]
-- to the form [coefficient] where the corresponding separations are 1, 2, ...
convert :: Integer -> [(Integer, Integer)] -> [Integer]
convert n eq = foldl foldF eq0 eq
	where
		eq0 = replicate (fromIntegral n `div` 2) 0
		foldF acc (sep, coef) = replaceAt (fromIntegral $ sep - 1) coef acc

-- generates a matrix that represents the system of equations of
-- (n/2) equations in the (n/2) variables g(1), g(2), ..., g(n/2).
genMatrix :: Integer -> Matrix Integer
genMatrix n = Matrix $ map mapF [1 .. n `div` 2]
	where mapF = convert n . combine . simplify n . genEq

-- finds g(n/2) using the system of equations / matrix.
-- note: A*x = B -> x = A^-1 * B
-- where A = square matrix of coefficients, generated by genMatrix.
--       x = column matrix of variables
--       B = column matrix of constants on the right side of the equation
--           (in this case, each element is -36.)
-- answer is expressed as a Rational.
-- small note: returns incorrect value for n = 2.
answer :: Integer -> Rational
answer n = head $ last $ fromMatrix matX
	where
		matA = fmap (% 1) $ genMatrix n
		matB = Matrix $ map (\x -> [x]) $
			replicate (fromIntegral n `div` 2) (-36 % 1)
		matX = inverse matA `mulM` matB

dblAnswer :: Integer -> Double
dblAnswer = fromRational . answer

main :: IO ()
main = print $ dblAnswer 100

-- Some notes
-- (includes some old stuff I tried before using matrices)

{-
How to find f(n) mathematically:

The possible separations of the 2 dice are 0 to n.
When the separation is 0 or n, the game is over.

let g(k) = the expected number of turns the game lasts, with n spots,
	and the dice start with a separation of k.
	Note that g(k) = g(n-k). Also g(0) = 0.

then
	g(k) = 1/2 * (g(k)+1) + 2/9 * (g(k-1)+1) + 2/9 * (g(k+1)+1) + 1/36 * (g(k-2)+1) + 1/36 * (g(k+2)+1)
	g(k) = 1/2 * (g(k)+1) + 2/9 * (g(k-1) + g(k+1) + 2) + 1/36 * (g(k-2) + g(k+2) + 2)
	36*g(k) = 18 * (g(k)+1) + 8 * (g(k-1) + g(k+1) + 2) + g(k-2) + g(k+2) + 2
	36*g(k) = 18*g(k) + 18 + 8*g(k-1) + 8*g(k+1) + 16 + g(k-2) + g(k+2) + 2
	18*g(k) = 8*g(k-1) + 8*g(k+1) + g(k-2) + g(k+2) + 36
	8*g(k-1) + 8*g(k+1) + g(k-2) + g(k+2) = 18*g(k) - 36
	g(k-2) + 8*g(k-1) - 18*g(k) + 8*g(k+1) + g(k+2) = -36
	
now, let k = 1, 2, ..., n/2 in the above equation.
Also, apply the rules g(k) = g(n-k), g(-1) = g(1), and g(0) = 0
	so that the only variables in these equations are g(1), g(2), ..., g(n/2).
Now you should have a system of (n/2) linear equations in (n/2) variables.
If you solve this system, then g(n/2) is f(n), the answer.
	(g(n/2) is also the greatest number out of the solutions to the system.)

--------------------------------------------------------------------------------

Let f(n) = the expected number of turns the game lasts, with n spots.

With math, I have found:

f(2)  = 9 / 4       = 2.25
f(4)  = 36 / 5      = 7.2
f(6)  = 675 / 44    = 15.34(09)
f(8)  = 1296 / 49   = 26.44897959...
f(10) = 17685 / 436 = 40.56192660...

--------------------------------------------------------------------------------

I used different seeds to pass to (mkStdGen), and then evaluated (expected 5000).
It took about 280 sec to evaluate each one.

Here are the results:

seed | expected
29   | 3714.3724
173  | 3747.9768
15   | 3744.1414
67   | 3849.2508
55   | 3775.4852
551  | 3850.8194
5512 | 3793.9888
1364 | 3763.561
1365 | 3812.7598

--------------------------------------------------------------------------------

After hardcoding the number 100 into the program, I decided to make functions
for arbitrary sizes of rings. These functions have '2' appended to the end
of their name.

I also checked that the arbitrary size functions were correct, by
evaluating (expected2 100 5000) with seed = 29. it was 3714.3724, so
the functions must be correct.

expression            | value

expected3 2 500000 37 | 2.253044
expected3 2 500000 38 | 2.245238

expected3 4 100000 25 | 7.20826
expected3 4 100000 26 | 7.19816
expected3 4 500000 27 | 7.200524
expected3 4 500000 28 | 7.200478
expected3 4 500000 29 | 7.19801

expected3 6 100000 26 | 15.35739
expected3 6 100000 27 | 15.39611
expected3 6 500000 29 | 15.321224

expected3 8 100000 33 | 26.50505
expected3 8 500000 34 | 26.447486

expected3 10 50000 21 | 40.57952
expected3 10 50000 23 | 40.6883
expected3 10 50000 24 | 40.63636

expected3 20 50000 20 | 155.79114
expected3 20 50000 21 | 156.65968

expected3 30 50000 39 | 344.95856
expected3 30 50000 40 | 346.4108

expected3 40 50000 41 | 614.1574
expected3 40 50000 42 | 610.67532

expected3 50 10000 27 | 955.5771
expected3 50 10000 28 | 969.7222
expected3 50 10000 29 | 948.8261
expected3 50 10000 30 | 944.8786
expected3 50 50000 45 | 951.46914
expected3 50 50000 46 | 952.50046

expected3 60 10000 30 | 1357.0141
expected3 60 10000 31 | 1355.8404

expected3 70 10000 43 | 1881.8608
expected3 70 10000 44 | 1890.8243

expected3 80 10000 34 | 2422.6017
expected3 80 10000 35 | 2394.5189
expected3 80 10000 36 | 2414.8424

expected3 90 10000 36 | 3051.6555
expected3 90 10000 37 | 3059.3852
-}